# ã‚¢ãƒªãƒ¼ãƒŠã®ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹

ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã¯ã€`aos`ã«ãŠã‘ã‚‹ã‚¢ãƒªãƒ¼ãƒŠã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚²ãƒ¼ãƒ ã‚’è¨­è¨ˆãŠã‚ˆã³ç®¡ç†ã™ã‚‹ãŸã‚ã«å¿…è¦ãªåŸºæœ¬çš„ãªãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹ã®åŒ…æ‹¬çš„ãªæ¦‚è¦ã‚’æä¾›ã—ã¾ã™ã€‚ã‚¢ãƒªãƒ¼ãƒŠã‚²ãƒ¼ãƒ ã§ã¯ã€å‚åŠ è€…ãŒãƒ©ã‚¦ãƒ³ãƒ‰ã”ã¨ã«æˆ¦ç•¥çš„ã«ç«¶ã„åˆã„ã€æœ€çµ‚çš„ã«å”¯ä¸€ã®å‹è€…ãŒå‡ºã‚‹ã¾ã§äº’ã„ã«æ’é™¤ã—ã¦ã„ãã¾ã™ã€‚

ã“ã“ã§ç¤ºã™ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ã€åŒã˜ã‚³ã‚¢æ©Ÿèƒ½ã‚’å…±æœ‰ã™ã‚‹ã•ã¾ã–ã¾ãªã‚²ãƒ¼ãƒ ã‚’ä½œæˆã™ã‚‹ãŸã‚ã®åŸºç›¤ã‚’æä¾›ã—ã¾ã™ã€‚ã‚²ãƒ¼ãƒ é–‹ç™ºã®è©³ç´°ã‚’æ¢æ±‚ã—ã€ã“ã®å¤šç›®çš„ã‚¢ãƒªãƒ¼ãƒŠã®ä¸­ã§å‰µé€ æ€§ã‚’ç™ºæ®ã—ã¾ã—ã‚‡ã†ã€‚

## ã‚³ã‚¢æ©Ÿèƒ½

ãã‚Œã§ã¯ã€ã‚¢ãƒªãƒ¼ãƒŠã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚²ãƒ¼ãƒ ã‚’æ”¯ãˆã‚‹ã‚³ã‚¢æ©Ÿèƒ½ã« dive ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

1. **ã‚²ãƒ¼ãƒ é€²è¡Œãƒ¢ãƒ¼ãƒ‰:**

ã‚¢ãƒªãƒ¼ãƒŠã‚²ãƒ¼ãƒ ã¯ã€ä»¥ä¸‹ã®é€²è¡Œãƒ¢ãƒ¼ãƒ‰ã§ãƒ«ãƒ¼ãƒ—ã™ã‚‹ãƒ©ã‚¦ãƒ³ãƒ‰ã«æ§‹æˆã•ã‚Œã¦ã„ã¾ã™: `"Not-Started"` â†’ `"Waiting"` â†’ `"Playing"` â†’ `[èª°ã‹ãŒå‹ã¤ã‹ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ]` â†’ `"Waiting"`...

> [!Note]
> å¾…æ©ŸçŠ¶æ…‹å¾Œã«ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã™ã‚‹ã®ã«ååˆ†ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„å ´åˆã€ãƒ«ãƒ¼ãƒ—ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚

ãƒ©ã‚¦ãƒ³ãƒ‰ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå‚åŠ ã™ã‚‹ãŸã‚ã®å®šç¾©ã•ã‚ŒãŸæ™‚é–“æ ã‚’æä¾›ã—ã€ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã®èˆˆå¥®ã‚’é«˜ã‚ã¾ã™ã€‚

2. **ãƒˆãƒ¼ã‚¯ãƒ³ã®è³­ã‘:**

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã‚²ãƒ¼ãƒ ã«å‚åŠ ã™ã‚‹ãŸã‚ã«ã€æŒ‡å®šã•ã‚ŒãŸæ•°é‡ã®ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ`PaymentQty`ã§å®šç¾©ï¼‰ã‚’é ã‘ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯ã€ã‚²ãƒ¼ãƒ ã«å…·ä½“çš„ãªè³­ã‘è¦ç´ ã‚’åŠ ãˆã¾ã™ã€‚

3. **ãƒœãƒ¼ãƒŠã‚¹å ±é…¬:**

å‹åˆ©ã®èˆˆå¥®ã‚’è¶…ãˆã¦ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯è¿½åŠ ã®å ±é…¬ã®è¦‹è¾¼ã¿ã«é­…äº†ã•ã‚Œã¾ã™ã€‚ãƒ“ãƒ«ãƒ€ãƒ¼ã¯ã€å„ãƒ©ã‚¦ãƒ³ãƒ‰ã”ã¨ã«åˆ†é…ã•ã‚Œã‚‹ãƒœãƒ¼ãƒŠã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ`BonusQty`ã§å®šç¾©ï¼‰ã‚’æä¾›ã™ã‚‹æŸ”è»Ÿæ€§ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè³­ã‘ãŸã™ã¹ã¦ã®é‡‘é¡ã‚‚ã“ã‚Œã‚‰ã®ãƒœãƒ¼ãƒŠã‚¹ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒœãƒ¼ãƒŠã‚¹ã¯è¿½åŠ ã®ã‚¤ãƒ³ã‚»ãƒ³ãƒ†ã‚£ãƒ–ã¨ã—ã¦æ©Ÿèƒ½ã—ã€ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã®ç«¶äº‰å¿ƒã‚’é«˜ã‚ã¾ã™ã€‚

4. **ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†:**

- æ¬¡ã®ã‚²ãƒ¼ãƒ ã«å‚åŠ ã™ã‚‹ã®ã‚’å¾…ã£ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã€`Waiting`ãƒ†ãƒ¼ãƒ–ãƒ«ã§è¿½è·¡ã•ã‚Œã¾ã™ã€‚
- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ãã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã¯ã€`Players`ãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚
- æ’é™¤ã•ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã€è¿…é€Ÿã«`Players`ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰å‰Šé™¤ã•ã‚Œã€æ¬¡ã®ã‚²ãƒ¼ãƒ ã®ãŸã‚ã«`Waiting`ãƒ†ãƒ¼ãƒ–ãƒ«ã«ç½®ã‹ã‚Œã¾ã™ã€‚

5. **ãƒ©ã‚¦ãƒ³ãƒ‰å‹è€…ã¸ã®å ±é…¬:**

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ’é™¤ã™ã‚‹ã¨ã€å‹è€…ã¯èª‡ã‚Šã ã‘ã§ãªãã€æ’é™¤ã•ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é ã‘ãƒˆãƒ¼ã‚¯ãƒ³ã‚‚å ±é…¬ã¨ã—ã¦ç²å¾—ã—ã¾ã™ã€‚ã•ã‚‰ã«ã€å„ãƒ©ã‚¦ãƒ³ãƒ‰ã®å‹è€…ã¯ãƒœãƒ¼ãƒŠã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¸€éƒ¨ã‚’å…±æœ‰ã—ã€å…ƒã®è³­ã‘é‡‘ã‚‚æ‰‹ã«å…¥ã‚Œã‚‹ã“ã¨ã§ã€å‹åˆ©ã‚’ç›®æŒ‡ã™å‹•æ©Ÿä»˜ã‘ãŒã•ã‚Œã¾ã™ã€‚

6. **ãƒªã‚¹ãƒŠãƒ¼ãƒ¢ãƒ¼ãƒ‰:**

ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¦³å¯Ÿã™ã‚‹ã“ã¨ã‚’å¥½ã‚€äººã€…ã®ãŸã‚ã«ã€ã€Œãƒªã‚¹ãƒ³ã€ãƒ¢ãƒ¼ãƒ‰ã¯ç©æ¥µçš„ãªå‚åŠ ãªã—ã§æƒ…å ±ã‚’å¾—ã‚‹æ©Ÿä¼šã‚’æä¾›ã—ã¾ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã¯ãƒªã‚¹ãƒŠãƒ¼ã¨ã—ã¦ç™»éŒ²ã§ãã€ã‚²ãƒ¼ãƒ ã‹ã‚‰ã®ã™ã¹ã¦ã®ç™ºè¡¨ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã—ã¦å‚åŠ ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ãƒªã‚¹ãƒŠãƒ¼ã¯æ˜ç¤ºçš„ã«å‰Šé™¤ã‚’è¦æ±‚ã™ã‚‹ã¾ã§ã‚²ãƒ¼ãƒ ã®é€²è¡Œã‚’è¦³å¯Ÿã—ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

7. **ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†:**

ã‚¢ãƒªãƒ¼ãƒŠã‚²ãƒ¼ãƒ ã®æµã‚Œã¨å…¬æ­£æ€§ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã«ã€è‡ªå‹•ã‚·ã‚¹ãƒ†ãƒ ãŒã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®é·ç§»ã‚’ç›£è¦–ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®é·ç§»ã«ã¯ã€å¾…æ©Ÿã€ãƒ—ãƒ¬ã‚¤ã€çµ‚äº†ã®å„ãƒ•ã‚§ãƒ¼ã‚ºãŒå«ã¾ã‚Œã¾ã™ã€‚`WaitTime`ã‚„`GameTime`ã®ã‚ˆã†ãªå„çŠ¶æ…‹ã®æ™‚é–“ã®å®šç¾©ã«ã‚ˆã‚Šã€ãƒ©ã‚¦ãƒ³ãƒ‰ãŒå®šç¾©ã•ã‚ŒãŸæ™‚é–“æ ã«å¾“ã†ã“ã¨ã‚’ä¿è¨¼ã—ã€ã‚²ãƒ¼ãƒ ãŒç„¡æœŸé™ã«ç¶šãã“ã¨ã‚’é˜²ãã¾ã™ã€‚

ã‚¢ãƒªãƒ¼ãƒŠã®ã‚³ãƒ¼ãƒ‰ã¯ã€ä»¥ä¸‹ã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã§å‚ç…§ã§ãã¾ã™ã€‚

<!-- # Mechanics of the Arena

This guide provides a comprehensive overview of the fundamental mechanics essential for designing and managing arena-style games in `aos`. In arena games, participants engage in rounds, strategically vying to eliminate each other until a sole victor emerges.

The framework presented here lays the groundwork for crafting a wide range of games, all sharing the same core functionalities. Explore the intricacies of game development and unleash your creativity within this versatile arena.

## Core Functionalities

Now, let's dive into the core functionalities that power arena-style games:

1. **Game Progression Modes:**

Arena games are structured into rounds that operate in a loop with the following progression modes: `"Not-Started"` â†’ `"Waiting"` â†’ `"Playing"` â†’ `[Someone wins or timeout]` â†’ `"Waiting"`...

> [!Note]
> The loop timesout if there are not enough players to start a game after the waiting state.

Rounds offer a defined timeframe for players to engage, intensifying the excitement of gameplay.

2. **Token Stakes:**

Players must deposit a specified quantity of tokens (defined by `PaymentQty`) to participate in the game. These tokens add a tangible stake element to the game.

3. **Bonus Rewards:**

Beyond the thrill of victory, players are enticed by the prospect of extra rewards. The builder has the flexibility to offer bonus tokens, defined by `BonusQty`, to be distributed per round. Any bets placed by players are also added to these bonuses. These bonuses serve as an additional incentive, enhancing the competitive spirit of the gameplay.

4. **Player Management:**

- Players waiting to join the next game are tracked in the `Waiting` table.
- Active players and their game states are stored in the `Players` table.
- Eliminated players are promptly removed from the `Players` table and placed in the `Waiting` table for the next game.

5. **Round Winner Reward:**

When a player eliminates another, they earn not only bragging rights but also the eliminated player's deposit tokens as a reward. Additionally, winners of each round share a portion of the bonus tokens, as well as their original stake, further motivating players to strive for victory.

6. **Listener Mode:**

For those who prefer to watch the action unfold, the "Listen" mode offers an opportunity to stay informed without active participation. Processes can register as listeners, granting them access to all announcements from the game. While they do not engage as players, listeners can continue to observe the game's progress unless they explicitly request removal.

7. **Game State Management:**

To maintain the flow and fairness of arena games, an automated system oversees game state transitions. These transitions encompass waiting, playing, and ending phases. Time durations for each state, such as `WaitTime` and `GameTime`, ensure that rounds adhere to defined timeframes, preventing games from lasting indefinitely.

You can refer to the code for the arena in the dropdown below: -->

<details>
  <summary><strong>Arena Game Blueprint</strong></summary>

```lua
-- ARENA GAME BLUEPRINT.

-- This blueprint provides the framework to operate an 'arena' style game
-- inside an ao process. Games are played in rounds, where players aim to
-- eliminate one another until only one remains, or until the game time
-- has elapsed. The game process will play rounds indefinitely as players join
-- and leave.

-- When a player eliminates another, they receive the eliminated player's deposit token
-- as a reward. Additionally, the builder can provide a bonus of these tokens
-- to be distributed per round as an additional incentive. If the intended
-- player type in the game is a bot, providing an additional 'bonus'
-- creates an opportunity for coders to 'mine' the process's
-- tokens by competing to produce the best agent.

-- The builder can also provide other handlers that allow players to perform
-- actions in the game, calling 'eliminatePlayer()' at the appropriate moment
-- in their game logic to control the framework.

-- Processes can also register in a 'Listen' mode, where they will receive
-- all announcements from the game, but are not considered for entry into the
-- rounds themselves. They are also not unregistered unless they explicitly ask
-- to be.

-- GLOBAL VARIABLES.

-- Game progression modes in a loop:
-- [Not-Started] -> Waiting -> Playing -> [Someone wins or timeout] -> Waiting...
-- The loop is broken if there are not enough players to start a game after the waiting state.
GameMode = GameMode or "Not-Started"
StateChangeTime = StateChangeTime or undefined

-- State durations (in milliseconds)
WaitTime = WaitTime or 2 * 60 * 1000 -- 2 minutes
GameTime = GameTime or 20 * 60 * 1000 -- 20 minutes
Now = Now or undefined -- Current time, updated on every message.

-- Token information for player stakes.
UNIT = 1000
PaymentToken = PaymentToken or "ADDR"  -- Token address
PaymentQty = PaymentQty or tostring(math.floor(UNIT))    -- Quantity of tokens for registration
BonusQty = BonusQty or tostring(math.floor(UNIT))        -- Bonus token quantity for winners

-- Players waiting to join the next game and their payment status.
Waiting = Waiting or {}
-- Active players and their game states.
Players = Players or {}
-- Number of winners in the current game.
Winners = 0
-- Processes subscribed to game announcements.
Listeners = Listeners or {}
-- Minimum number of players required to start a game.
MinimumPlayers = MinimumPlayers or 2

-- Default player state initialization.
PlayerInitState = PlayerInitState or {}

-- Sends a state change announcement to all registered listeners.
-- @param event: The event type or name.
-- @param description: Description of the event.
function announce(event, description)
    for ix, address in pairs(Listeners) do
        ao.send({
            Target = address,
            Action = "Announcement",
            Event = event,
            Data = description
        })
    end
    return print(Colors.gray .. "Announcement: " .. Colors.red .. event .. " " .. Colors.blue .. description .. Colors.reset)
end

-- Sends a reward to a player.
-- @param recipient: The player receiving the reward.
-- @param qty: The quantity of the reward.
-- @param reason: The reason for the reward.
function sendReward(recipient, qty, reason)
    if type(qty) ~= number then
      qty = tonumber(qty)
    end
    ao.send({
        Target = PaymentToken,
        Action = "Transfer",
        Quantity = tostring(qty),
        Recipient = recipient,
        Reason = reason
    })
    return print(Colors.gray .. "Sent Reward: " ..
      Colors.blue .. tostring(qty) ..
      Colors.gray .. ' tokens to ' ..
      Colors.green .. recipient .. " " ..
      Colors.blue .. reason .. Colors.reset
    )
end

-- Starts the waiting period for players to become ready to play.
function startWaitingPeriod()
    GameMode = "Waiting"
    StateChangeTime = Now + WaitTime
    announce("Started-Waiting-Period", "The game is about to begin! Send your token to take part.")
    print('Starting Waiting Period')
end

-- Starts the game if there are enough players.
function startGamePeriod()
    local paidPlayers = 0
    for player, hasPaid in pairs(Waiting) do
        if hasPaid then
            paidPlayers = paidPlayers + 1
        end
    end

    if paidPlayers < MinimumPlayers then
        announce("Not-Enough-Players", "Not enough players registered! Restarting...")
        for player, hasPaid in pairs(Waiting) do
            if hasPaid then
                Waiting[player] = false
                sendReward(player, PaymentQty, "Refund")
            end
        end
        startWaitingPeriod()
        return
    end

    LastTick = undefined
    GameMode = "Playing"
    StateChangeTime = Now + GameTime
    for player, hasPaid in pairs(Waiting) do
        if hasPaid then
            Players[player] = playerInitState()
        else
            ao.send({
                Target = player,
                Action = "Ejected",
                Reason = "Did-Not-Pay"
            })
            removeListener(player) -- Removing player from listener if they didn't pay
        end
    end
    announce("Started-Game", "The game has started. Good luck!")
    print("Game Started....")
end

-- Handles the elimination of a player from the game.
-- @param eliminated: The player to be eliminated.
-- @param eliminator: The player causing the elimination.
function eliminatePlayer(eliminated, eliminator)
    sendReward(eliminator, PaymentQty, "Eliminated-Player")
    Waiting[eliminated] = false
    Players[eliminated] = nil

    ao.send({
        Target = eliminated,
        Action = "Eliminated",
        Eliminator = eliminator
    })

    announce("Player-Eliminated", eliminated .. " was eliminated by " .. eliminator .. "!")

    local playerCount = 0
    for player, _ in pairs(Players) do
        playerCount = playerCount + 1
    end
    print("Eliminating player: " .. eliminated .. " by: " .. eliminator) -- Useful for tracking eliminations

    if playerCount < MinimumPlayers then
        endGame()
    end

end

-- Ends the current game and starts a new one.
function endGame()
    print("Game Over")

    Winners = 0
    Winnings = tonumber(BonusQty) / Winners -- Calculating winnings per player

    for player, _ in pairs(Players) do
        Winners = Winners + 1
    end

    Winnings = tonumber(BonusQty) / Winners

    for player, _ in pairs(Players) do
        -- addLog("EndGame", "Sending reward of:".. Winnings + PaymentQty .. "to player: " .. player) -- Useful for tracking rewards
        sendReward(player, Winnings + tonumber(PaymentQty), "Win")
        Waiting[player] = false
    end

    Players = {}
    announce("Game-Ended", "Congratulations! The game has ended. Remaining players at conclusion: " .. Winners .. ".")
    startWaitingPeriod()
end

-- Removes a listener from the listeners' list.
-- @param listener: The listener to be removed.
function removeListener(listener)
    local idx = 0
    for i, v in ipairs(Listeners) do
        if v == listener then
            idx = i
            break
        end
    end
    if idx > 0 then
        table.remove(Listeners, idx)
    end
end

-- HANDLERS: Game state management

-- Handler for cron messages, manages game state transitions.
Handlers.add(
    "Game-State-Timers",
    function(Msg)
        return "continue"
    end,
    function(Msg)
        Now = Msg.Timestamp
        if GameMode == "Not-Started" then
            startWaitingPeriod()
        elseif GameMode == "Waiting" then
            if Now > StateChangeTime then
                startGamePeriod()
            end
        elseif GameMode == "Playing" then
            if onTick and type(onTick) == "function" then
              onTick()
            end
            if Now > StateChangeTime then
                endGame()
            end
        end
    end
)

-- Handler for player deposits to participate in the next game.
Handlers.add(
    "Transfer",
    function(Msg)
        return
            Msg.Action == "Credit-Notice" and
            Msg.From == PaymentToken and
            tonumber(Msg.Quantity) >= tonumber(PaymentQty) and "continue"
    end,
    function(Msg)
        Waiting[Msg.Sender] = true
        ao.send({
            Target = Msg.Sender,
            Action = "Payment-Received"
        })
        announce("Player-Ready", Msg.Sender .. " is ready to play!")
    end
)

-- Registers new players for the next game and subscribes them for event info.
Handlers.add(
    "Register",
   { Action = "Register" },
    function(Msg)
        if Msg.Mode ~= "Listen" and Waiting[Msg.From] == undefined then
            Waiting[Msg.From] = false
        end
        removeListener(Msg.From)
        table.insert(Listeners, Msg.From)
        ao.send({
            Target = Msg.From,
            Action = "Registered"
        })
        announce("New Player Registered", Msg.From .. " has joined in waiting.")
    end
)

-- Unregisters players and stops sending them event info.
Handlers.add(
    "Unregister",
   { Action = "Unregister" },
    function(Msg)
        removeListener(Msg.From)
        ao.send({
            Target = Msg.From,
            Action = "Unregistered"
        })
    end
)

-- Adds bet amount to BonusQty
Handlers.add(
    "AddBet",
    { Reason = "AddBet" },
    function(Msg)
        BonusQty = tonumber(BonusQty) + tonumber(Msg.Tags.Quantity)
        announce("Bet-Added", Msg.From .. "has placed a bet. " .. "BonusQty amount increased by " .. Msg.Tags.Quantity .. "!")
    end
)

-- Retrieves the current game state.
Handlers.add(
    "GetGameState",
   { Action = "GetGameState" },
    function (Msg)
        local json = require("json")
        local TimeRemaining = StateChangeTime - Now
        local GameState = json.encode({
            GameMode = GameMode,
            TimeRemaining = TimeRemaining,
            Players = Players,
            })
        ao.send({
            Target = Msg.From,
            Action = "GameState",
            Data = GameState})
    end
)

-- Alerts users regarding the time remaining in each game state.
Handlers.add(
    "AnnounceTick",
   { Action = "Tick" },
    function (Msg)
        local TimeRemaining = StateChangeTime - Now
        if GameMode == "Waiting" then
            announce("Tick", "The game will start in " .. (TimeRemaining/1000) .. " seconds.")
        elseif GameMode == "Playing" then
            announce("Tick", "The game will end in " .. (TimeRemaining/1000) .. " seconds.")
        end
    end
)

-- Sends tokens to players with no balance upon request
Handlers.add(
    "RequestTokens",
   { Action = "RequestTokens" },
    function (Msg)
        print("Transfering Tokens: " .. tostring(math.floor(10000 * UNIT)))
        ao.send({
            Target = ao.id,
            Action = "Transfer",
            Quantity = tostring(math.floor(10000 * UNIT)),
            Recipient = Msg.From,
        })
    end
)
```

</details>

## ã‚¢ãƒªãƒ¼ãƒŠã‚²ãƒ¼ãƒ ãƒ–ãƒ«ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ

ã“ã®ã‚¢ãƒªãƒ¼ãƒŠãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’åˆ©ç”¨ã—ãŸã„æ–¹ã®ãŸã‚ã«ã€ã‚³ãƒ¼ãƒ‰ã‚’ãƒ–ãƒ«ãƒ¼ãƒ—ãƒªãƒ³ãƒˆã¨ã—ã¦ç°¡å˜ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼š

<!--
## Arena Game Blueprint

For those interested in using this arena framework, we've made this code easily accesible through a blueprint. Simply run the following code in your terminal: -->

```lua
.load-blueprint arena
```

## è¦ç´„

ã‚¢ãƒªãƒ¼ãƒŠã®ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹ã‚’ç†è§£ã™ã‚‹ã“ã¨ã¯ã€å‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ä½œæˆã—ãŸè‡ªå¾‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ”¹å–„ã™ã‚‹ã ã‘ã§ãªãã€ç‹¬è‡ªã®ã‚²ãƒ¼ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®ã‚³ã‚¢æ©Ÿèƒ½ã‚’æ´»ç”¨ã™ã‚‹åŠ›ã‚’ä¸ãˆã¾ã™ã€‚

æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€Œã‚²ãƒ¼ãƒ ã®æ§‹ç¯‰ã€ã§ã¯ã€ã“ã‚Œã‚‰ã®ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹ã‚’æ´»ç”¨ã—ã¦é­…åŠ›çš„ã§ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã‚²ãƒ¼ãƒ ã‚’ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å†…ã§æ§‹ç¯‰ã™ã‚‹ã‚¢ãƒ¼ãƒˆã«æ·±ãæ˜ã‚Šä¸‹ã’ã¾ã™ã€‚ã‚²ãƒ¼ãƒ é–‹ç™ºã®ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãªä¸–ç•Œã¸ã®æ—…ã«å‡ºã‚‹æº–å‚™ã‚’ã—ã¦ãã ã•ã„ï¼ ğŸ®

<!-- ## Summary

Understanding the mechanics of the arena can not only help you improve your autonomous agent created in the previous section but also empowers you to harness core functionalities for crafting your unique games.

In the upcoming section, "Building a Game," we will dive deep into the art of utilizing these mechanics to construct captivating and one-of-a-kind games within this framework. Get ready to embark on a journey into the dynamic realm of game development! ğŸ® -->
